"""
Test runner for the JSON Schema official test suite

Tests comprehensive correctness of each draft's validator.

Thank you https://github.com/json-schema/JSON-Schema-Test-Suite for all the work in this file.
"""
from __future__ import print_function

import glob
import json
import io
import itertools
import os
import re
import sys

try:
    from sys import pypy_version_info
except ImportError:
    pypy_version_info = None

if sys.maxunicode == 2 ** 16 - 1:          # This is a narrow build.
    def narrow_unicode_build(case, test):
        if "supplementary Unicode" in test["description"]:
            return "Not running surrogate Unicode case, this Python is narrow."
else:
    def narrow_unicode_build(case, test):  # This isn't, skip nothing.
        return


PY3 = sys.version_info[0] == 3

REPO_ROOT = os.path.abspath(os.path.dirname(__file__))
SUITE = os.getenv("JSON_SCHEMA_TEST_SUITE", os.path.join(REPO_ROOT, "JSON-Schema-Test-Suite"))
TESTS_DIR = os.path.join(SUITE, "tests")


import unittest


from validictory import validate, FieldValidationError
from validictory.preprocess_ref import preprocess_ref


# def add_tests(tests):
#     def class_decorator(cls):
#         """Add tests to `cls` generated by `generator()`."""
#         for f, input, output in generator():
#             test = lambda self, i=input, o=output, f=f: f(self, i, o)
#             test.__name__ = "test_%s(%r, %r)" % (f.__name__, input, output)
#             setattr(cls, test.__name__, test)
#     return class_decorator


def add_tests(tests):
    def class_decorator(cls):
        for name, test in tests:
            setattr(cls, name, test)
        return cls
    return class_decorator


def make_case(schema, data, valid, name):
    if valid:
        def test_case(self):
            # kwargs = getattr(self, "validator_kwargs", {})
            schema2 = preprocess_ref(schema)
            print('data', data)
            print('schema', schema)
            print("should be valid")
            validate(data, schema2, required_by_default=False)
            # , cls=self.validator_class, **kwargs)
    else:
        def test_case(self):
            # kwargs = getattr(self, "validator_kwargs", {})
            print('data', data)
            print('schema', schema)
            print("should be invalid")
            with self.assertRaises(FieldValidationError):
                schema2 = preprocess_ref(schema)
                validate(data, schema2, required_by_default=False)
                # , cls=self.validator_class, **kwargs)

    if not PY3:
        name = name.encode("utf-8")
    test_case.__name__ = name

    return test_case


def maybe_skip(skip, test_case, case, test):
    if skip is not None:
        reason = skip(case, test)
        if reason is not None:
            test_case = unittest.skip(reason)(test_case)
    return test_case


def load_json_cases_gen(
    tests_glob,
    ignore_glob="",
    basedir=TESTS_DIR,
    skip=None
):
    if ignore_glob:
        ignore_glob = os.path.join(basedir, ignore_glob)

    ignored = set(glob.iglob(ignore_glob))

    def gen():
        for filename in glob.iglob(os.path.join(basedir, tests_glob)):
            if filename in ignored:
                continue

            validating, _ = os.path.splitext(os.path.basename(filename))
            id = itertools.count(1)

            with open(filename) as test_file:
                for case in json.load(test_file):
                    for test in case["tests"]:
                        name = "test_%s_%s_%s" % (
                            validating,
                            next(id),
                            re.sub(r"[\W ]+", "_", test["description"]),
                        )
                        test_case = make_case(
                            data=test["data"],
                            schema=case["schema"],
                            valid=test["valid"],
                            name=name,
                        )
                        test_case = maybe_skip(skip, test_case, case, test)
                        yield name, test_case

    return list(gen())


std_tests = load_json_cases_gen(
    tests_glob="draft4/*.json",
    skip=narrow_unicode_build,
    ignore_glob="draft4/refRemote.json",
)
TestJsonSchemaDraft4 = add_tests(std_tests)(unittest.TestCase)


import mock
import subprocess


JSONSCHEMA_SUITE = os.path.join(SUITE, "bin", "jsonschema_suite")
remotes_stdout = subprocess.check_output(
    ["python", JSONSCHEMA_SUITE, "remotes"]
)
if PY3:
    remotes_stdout = remotes_stdout.decode('utf8')
REMOTES = json.loads(remotes_stdout)


def mock_get_ref_definition(schema, matched_value):
    print('schema', schema)
    print('matched_value', matched_value)
    print('known_remotes', REMOTES.keys())
    _, _, reference = matched_value.partition("http://localhost:1234/")
    print('reference', reference)
    return mock.Mock(return_value=REMOTES.get(reference))


class TestDraft4RemoteResolution(unittest.TestCase):
    def setUp(self):
        patch = mock.patch("validictory.preprocess_ref.get_ref_definition")
        mo = patch.start()
        mo.side_effect = mock_get_ref_definition
        self.addCleanup(patch.stop)


rem_tests = load_json_cases_gen(
    tests_glob="draft4/refRemote.json",
    skip=narrow_unicode_build,
)
TestDraft4RemoteResolution = add_tests(rem_tests)(TestDraft4RemoteResolution)


if __name__ == '__main__':
    unittest.main()
